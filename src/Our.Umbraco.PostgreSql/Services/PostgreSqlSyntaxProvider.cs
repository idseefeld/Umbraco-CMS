using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NPoco;
using Our.Umbraco.PostgreSql.Mappers;
using Umbraco.Cms.Core;
using Umbraco.Cms.Core.Configuration.Models;
using Umbraco.Cms.Core.Persistence;
using Umbraco.Cms.Infrastructure.Persistence;
using Umbraco.Cms.Infrastructure.Persistence.DatabaseAnnotations;
using Umbraco.Cms.Infrastructure.Persistence.DatabaseModelDefinitions;
using Umbraco.Cms.Infrastructure.Persistence.SqlSyntax;
using Umbraco.Extensions;
using UCC = Umbraco.Cms.Core;
using ColumnInfo = Umbraco.Cms.Infrastructure.Persistence.SqlSyntax.ColumnInfo;
using Our.Umbraco.PostgreSql.Helper;

namespace Our.Umbraco.PostgreSql.Services;

/// <summary>
///     Represents a SqlSyntaxProvider for PostgreSQL.
/// </summary>
public class PostgreSqlSyntaxProvider : SqlSyntaxProviderBase<PostgreSqlSyntaxProvider>
{
    private readonly IOptions<GlobalSettings> _globalSettings;
    private readonly ILogger<PostgreSqlSyntaxProvider> _logger;
    private readonly IDictionary<Type, IScalarMapper> _scalarMappers;

    /// <summary>
    /// Initializes a new instance of the <see cref="PostgreSqlSyntaxProvider"/> class.
    /// </summary>
    /// <param name="globalSettings">Inject Globalsettings from configuration.</param>
    /// <param name="logger">Inject Logger.</param>
    public PostgreSqlSyntaxProvider(
        IOptions<GlobalSettings> globalSettings,
        ILogger<PostgreSqlSyntaxProvider> logger)
    {
        _globalSettings = globalSettings;
        _logger = logger;

        _scalarMappers = new Dictionary<Type, IScalarMapper>
        {
            [typeof(Guid)] = new PostgreSqlGuidScalarMapper(),
            [typeof(Guid?)] = new PostgreSqlNullableGuidScalarMapper(),
            [typeof(DateTime)] = new PostgreSqlDateTimeScalarMapper(),
            [typeof(DateTime?)] = new PostgreSqlNullableDateTimeScalarMapper(),
        };

        AutoIncrementDefinition = "GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 )"; // "SERIAL"

        IntColumnDefinition = "INTEGER";
        LongColumnDefinition = "BIGINT";
        BoolColumnDefinition = "BOOLEAN";

        GuidColumnDefinition = "UUID";
        DateTimeColumnDefinition = "TIMESTAMP WITHOUT TIME ZONE";
        DateTimeOffsetColumnDefinition = "TIMESTAMP WITHOUT TIME ZONE"; // "TIMESTAMPTZ";
        TimeColumnDefinition = "TIME";
        DecimalColumnDefinition = "NUMERIC(20,9)";

        RealColumnDefinition = "DOUBLE PRECISION";

        BlobColumnDefinition = "BYTEA";
    }

    /// <summary>
    /// Gets the SQL definition string used to create an auto-incrementing 64-bit integer column.
    /// </summary>
    /// <remarks>This definition is typically used when generating database schema for columns that require
    /// automatic incrementing of long integer values, such as primary keys. The format follows standard SQL identity
    /// syntax for 64-bit integers.</remarks>
    public string AutoIncrementLongDefinition { get; protected set; } = "GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 )"; // "BIGSERIAL"


    /// <inheritdoc />
    public override string ProviderName => Constants.ProviderName;

    public override IsolationLevel DefaultIsolationLevel => IsolationLevel.ReadCommitted;

    /// <inheritdoc />
    public override string StringLengthUnicodeColumnDefinitionFormat { get; } = "NATIONAL CHARACTER VARYING({0})";

    /// <inheritdoc />
    public override string DbProvider => Constants.ProviderName;

    /// <inheritdoc />
    public override bool SupportsClustered() => false; // PostgreSQL does not support clustered indexes

    /// <inheritdoc />
    public override bool SupportsIdentityInsert() => false; // PostgreSQL does not support identity insert

    /// <inheritdoc />
    public override string StringColumnDefinition { get; } = "TEXT";

    /// <inheritdoc />
    public override string CreateForeignKeyConstraint => "ALTER TABLE {0} ADD CONSTRAINT {1} FOREIGN KEY ({2}) REFERENCES {3} ({4}){5}{6}{7}";

    /// <inheritdoc />
    public override string CreateDefaultConstraint => "ALTER TABLE {0} ALTER COLUMN {3} SET DEFAULT {2}";

    /// <inheritdoc />
    public new string StringLengthColumnDefinitionFormat { get; } = "TEXT";

    /// <inheritdoc/>
    public override string GetWildcardConcat(string concatDefault = "") =>
        base.GetWildcardConcat(concatDefault);

    /// <inheritdoc/>
    public override DatabaseType GetUpdatedDatabaseType(DatabaseType current, string? connectionString)
    {
        // the following is needed to avoid issues with casing when comparing strings in Postgres. ATTENTION: this needs an updated NPoco version that supports this flag!
        // current.EscapeTableColumAliasNames = false;

        return current;
    }

    /// <inheritdoc/>
    public override void HandleCreateTable(IDatabase database, TableDefinition tableDefinition, bool skipKeysAndIndexes = false)
    {
        // Format columns, primary key, and foreign keys
        var columns = Format(tableDefinition.Columns);
        var primaryKey = FormatPrimaryKey(tableDefinition);

        var sb = new System.Text.StringBuilder();
        _ = sb.AppendLine($"CREATE TABLE {GetQuotedTableName(tableDefinition.Name)}")
            .AppendLine("(")
            .Append(columns);

        // Add primary key if present and not skipping keys
        if (!string.IsNullOrEmpty(primaryKey) && !skipKeysAndIndexes)
        {
            _ = sb.AppendLine($",\n {primaryKey}");
        }

        var createSql = sb
            .AppendLine(")")
            .ToString();

        _logger.LogInformation("Create table:\n {Sql}", createSql);
        _ = database.Execute(new Sql(createSql));

        if (skipKeysAndIndexes)
        {
            return;
        }

        // Create indexes
        List<string> indexSql = Format(tableDefinition.Indexes);
        foreach (var sql in indexSql)
        {
            _logger.LogDebug("Create Index:\n {Sql}", sql);
            _ = database.Execute(new Sql(sql));
        }

        // Create foreign keys
        List<string> foreignKeysSql = Format(tableDefinition.ForeignKeys);
        foreach (var sql in foreignKeysSql)
        {
            _logger.LogDebug("Create Index:\n {Sql}", sql);
            _ = database.Execute(new Sql(sql));
        }
    }

    /// <inheritdoc />
    public override string OrderByGuid(string tableName, string columnName) => $"UPPER({GetQuotedColumn(tableName, columnName)}::text)";

    /// <inheritdoc />
    private string GetQuotedColumn(string tableName, string columnName) => GetQuotedTableName(tableName) + "." + GetQuotedColumnName(columnName);

    /// <inheritdoc />
    public override string GetStringColumnEqualComparison(string column, int paramIndex, TextColumnType columnType)
    {
        return $"UPPER({column}::text) = UPPER(@{paramIndex})";
    }

    /// <inheritdoc />
    public override string GetStringColumnWildcardComparison(string column, int paramIndex, TextColumnType columnType)
    {
        return $"UPPER({column}::text) LIKE UPPER(@{paramIndex})";
    }

    /// <inheritdoc />
    public override string GetConcat(params string[] args) => string.Join(" || ", args);

    private readonly string[] SqlKeywords = ["USER", "ORDER", "GROUP", "SELECT", "INSERT", "UPDATE", "DELETE", "TABLE", "COLUMN", "INDEX", "WHERE", "FROM", "JOIN"];

    

    private string GetQuotedIdentifier(string? identifier)
    {
        if (string.IsNullOrWhiteSpace(identifier))
        {
            throw new ArgumentNullException(nameof(identifier));
        }

        // ToDo: when NPoco supports EscapeTableColumAliasNames, this could be simplified
        PropertyInfo? escapeTableColumAliasNamesProperty = ReflectionHelper.GetInterfaceProperty(typeof(IDatabaseType), "EscapeTableColumAliasNames", typeof(bool));
        var escapeTableColumAliasNames = escapeTableColumAliasNamesProperty == null
            ? false
            : (bool?)escapeTableColumAliasNamesProperty.GetValue(escapeTableColumAliasNamesProperty) ?? false;

        var rVal = !escapeTableColumAliasNames || SqlKeywords.InvariantContains(identifier) ? $"\"{identifier}\"" : $"{identifier}";
        return rVal;
    }

    /// <inheritdoc />
    public override string GetQuotedTableName(string? tableName) => GetQuotedIdentifier(tableName);
    /// <inheritdoc />
    public override string GetQuotedColumnName(string? columnName) => GetQuotedIdentifier(columnName);

    /// <inheritdoc />
    public override string GetQuotedName(string? name) => GetQuotedIdentifier(name);

    /// <inheritdoc />
    public override string GetQuotedValue(string value) => $"'{value.Replace("'", "''")}'";

    /// <inheritdoc />
    public override string GetIndexType(IndexTypes indexTypes)
    {
        switch (indexTypes)
        {
            case IndexTypes.UniqueNonClustered:
            case IndexTypes.UniqueClustered:
                return "UNIQUE";
            default:
                return string.Empty;
        }
    }

    /// <inheritdoc />
    public override string GetSpecialDbType(SpecialDbType dbType)
    {
        if (dbType == SpecialDbType.NCHAR)
        {
            return "CHAR";
        }

        return "TEXT";
    }

    /// <inheritdoc />
    public override string GetColumn(DatabaseType dbType, string tableName, string columnName, string? columnAlias, string? referenceName = null, bool forInsert = false)
    {
        tableName = GetQuotedTableName(tableName);
        columnName = GetQuotedColumnName(columnName);
        var column = forInsert ? columnName : tableName + "." + columnName;
        if (columnAlias == null)
        {
            return column;
        }

        referenceName = referenceName == null ? string.Empty : referenceName + "__";
        columnAlias = GetQuotedColumnName(referenceName + columnAlias);
        column += " AS " + columnAlias;
        return column;
    }

    /// <inheritdoc />
    public override IEnumerable<string> GetTablesInSchema(IDatabase db)
    {
        List<string> rVal = db.Fetch<string>("SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'");
        return rVal;
    }

    /// <inheritdoc />
    public override IEnumerable<ColumnInfo> GetColumnsInSchema(IDatabase db)
    {
        const string sql = @"
            SELECT
                table_name AS ""TableName"",
                column_name AS ""ColumnName"",
                ordinal_position AS ""Ordinal"",
                column_default AS ""ColumnDefault"",
                is_nullable = 'YES' AS ""IsNullable"",
                data_type AS ""DataType""
              FROM information_schema.columns
              WHERE table_schema = 'public'";

        return db.Fetch<ColumnInfo>(sql);
    }

    /// <inheritdoc />
    public override IEnumerable<Tuple<string, string>> GetConstraintsPerTable(IDatabase db)
    {
        const string sql = @"
        SELECT
            tc.table_name AS ""TableName"",
            tc.constraint_name AS ""ColumnName""
        FROM information_schema.table_constraints tc
        WHERE tc.table_schema = 'public'";

        List<ConstraintsPerColumn> temp = db.Fetch<ConstraintsPerColumn>(sql);
        var rVal = temp.Select(x => new Tuple<string, string>(x.TableName, x.ConstraintName)).ToList();
        return rVal;
    }

    /// <inheritdoc />
    public override IEnumerable<Tuple<string, string, string>> GetConstraintsPerColumn(IDatabase db)
    {
        const string sql = @"
        SELECT
            tc.table_name AS ""TableName"",
            kcu.column_name AS ""ColumnName"",
            tc.constraint_name AS ""ConstraintName""
        FROM
            information_schema.table_constraints AS tc
            JOIN information_schema.key_column_usage AS kcu
                ON tc.constraint_name = kcu.constraint_name
                AND tc.table_schema = kcu.table_schema
        WHERE
            tc.table_schema = 'public'
        UNION
        SELECT
            tc.table_name,
            ccu.column_name,
            tc.constraint_name
        FROM
            information_schema.table_constraints AS tc
            JOIN information_schema.constraint_column_usage AS ccu
                ON tc.constraint_name = ccu.constraint_name
                AND tc.table_schema = ccu.table_schema
        WHERE
            tc.table_schema = 'public'
            AND tc.constraint_type = 'CHECK'
    ";

        List<ConstraintsPerColumn> temp = db.Fetch<ConstraintsPerColumn>(sql);
        var rVal = temp.Select(x => new Tuple<string, string, string>(x.TableName, x.ColumnName, x.ConstraintName)).ToList();
        return rVal;
    }

    /// <inheritdoc />
    public override bool DoesPrimaryKeyExist(IDatabase db, string tableName, string primaryKeyName)
    {
        var result = db.ExecuteScalar<int>(
            @"SELECT COUNT(*)
              FROM information_schema.table_constraints
              WHERE table_name = @0 AND constraint_type = 'PRIMARY KEY' AND constraint_name = @1",
            tableName, primaryKeyName);
        return result > 0;
    }

    /// <inheritdoc />
    public override string GetFieldNameForUpdate<TDto>(Expression<Func<TDto, object?>> fieldSelector, string? tableAlias = null)
    {
        PropertyInfo field = ExpressionHelper.FindProperty(fieldSelector).Item1 as PropertyInfo
            ?? throw new ArgumentNullException(nameof(fieldSelector), "Field selector must return a valid property.");

        ColumnAttribute? attr = field?.FirstAttribute<ColumnAttribute>();
        var fieldName = string.IsNullOrWhiteSpace(attr?.Name) ? field?.Name : attr.Name;

        return GetQuotedColumnName(fieldName);
    }

    /// <inheritdoc />
    public override Sql<ISqlContext> InsertForUpdateHint(Sql<ISqlContext> sql) => sql;

    /// <inheritdoc />
    public override Sql<ISqlContext> AppendForUpdateHint(Sql<ISqlContext> sql) => sql;
    /// <inheritdoc/>
    public override IDictionary<Type, IScalarMapper> ScalarMappers => _scalarMappers;

    /// <inheritdoc />
    public override bool DoesTableExist(IDatabase db, string tableName) => GetTablesInSchema(db).Contains(tableName);


    /// <inheritdoc />
    public override string FormatDateTime(DateTime date, bool includeTime = true)
    {
        return date.ToString(includeTime ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd", CultureInfo.InvariantCulture);
    }

    /// <inheritdoc />
    public override string Format(TableDefinition table)
    {
        var statement = string.Format(CreateTable, GetQuotedTableName(table.Name), Format(table.Columns));
        return statement;
    }

    /// <inheritdoc />
    public override string ConvertIntegerToBoolean(int value) => value == 0 ? "false" : "true";

    /// <inheritdoc />
    public override List<string> Format(IEnumerable<IndexDefinition> indexes) => indexes.Select(Format).ToList();

    /// <inheritdoc />
    public override string Format(IndexDefinition index)
    {
        var name = string.IsNullOrEmpty(index.Name)
            ? $"IX_{index.TableName}_{index.ColumnName}"
            : index.Name;

        var columns = index.Columns.Any()
            ? string.Join(",", index.Columns.Select(x => GetQuotedColumnName(x.Name)))
            : GetQuotedColumnName(index.ColumnName);

        return string.Format(
            CreateIndex,
            GetIndexType(index.IndexType),
            " ",
            GetQuotedName(name),
            GetQuotedTableName(index.TableName),
            columns);
    }

    /// <inheritdoc />
    public override List<string> Format(IEnumerable<ForeignKeyDefinition> foreignKeys) =>
        foreignKeys.Select(Format).ToList();

    /// <inheritdoc />
    public override string Format(ForeignKeyDefinition foreignKey)
    {
        var constraintName = string.IsNullOrEmpty(foreignKey.Name)
            ? $"FK_{foreignKey.ForeignTable}_{foreignKey.PrimaryTable}_{foreignKey.PrimaryColumns.First()}"
            : foreignKey.Name;

        var anyRule = foreignKey.OnDelete != Rule.None || foreignKey.OnUpdate != Rule.None;
        var deferrableInitiallyDeferredSql = anyRule ? string.Empty : " DEFERRABLE INITIALLY DEFERRED ";

        return string.Format(
            CreateForeignKeyConstraint,
            GetQuotedTableName(foreignKey.ForeignTable),
            GetQuotedName(constraintName),
            GetQuotedColumnName(foreignKey.ForeignColumns.First()),
            GetQuotedTableName(foreignKey.PrimaryTable),
            GetQuotedColumnName(foreignKey.PrimaryColumns.First()),
            deferrableInitiallyDeferredSql,
            FormatCascade("DELETE", foreignKey.OnDelete),
            FormatCascade("UPDATE", foreignKey.OnUpdate));
    }

    /// <inheritdoc />
    public override string Format(IEnumerable<ColumnDefinition> columns)
    {
        var sb = new StringBuilder();
        foreach (ColumnDefinition column in columns)
        {
            sb.Append(Format(column) + ",\n");
        }
        return sb.ToString().TrimEnd(",\n");
    }

    /// <inheritdoc />
    public override string Format(ColumnDefinition column) =>
        string.Join(" ", ClauseOrder
            .Select(action => action(column))
            .Where(clause => string.IsNullOrEmpty(clause) == false));

    /// <inheritdoc />
    public override string Format(ColumnDefinition column, string tableName, out IEnumerable<string> sqls)
    {
        var sql = new StringBuilder();
        sql.Append(FormatString(column));
        sql.Append(" ");
        sql.Append(FormatType(column));
        sql.Append(" ");
        sql.Append("NULL"); // always nullable
        sql.Append(" ");
        sql.Append(FormatConstraint(column));
        sql.Append(" ");
        sql.Append(FormatDefaultValue(column));
        sql.Append(" ");
        sql.Append(FormatPrimaryKey(column));
        sql.Append(" ");
        sql.Append(FormatIdentity(column));

        var msql = new List<string>();
        sqls = msql;

        var alterSql = new StringBuilder();
        alterSql.Append(FormatString(column));
        alterSql.Append(" ");
        alterSql.Append(FormatType(column));
        alterSql.Append(" ");
        alterSql.Append(FormatNullable(column));
        msql.Add(string.Format(AlterColumn, tableName, alterSql));

        return sql.ToString();
    }

    /// <inheritdoc />
    public override string FormatPrimaryKey(TableDefinition table)
    {
        ColumnDefinition? columnDefinition = table.Columns.FirstOrDefault(x => x.IsPrimaryKey);
        if (columnDefinition == null)
        {
            return string.Empty;
        }

        var constraintName = string.IsNullOrEmpty(columnDefinition.PrimaryKeyName)
            ? $"PK_{table.Name}"
            : columnDefinition.PrimaryKeyName;

        var columns = string.IsNullOrEmpty(columnDefinition.PrimaryKeyColumns)
            ? GetQuotedColumnName(columnDefinition.Name)
            : string.Join(", ", columnDefinition.PrimaryKeyColumns
                .Split(UCC.Constants.CharArrays.CommaSpace, StringSplitOptions.RemoveEmptyEntries)
                .Select(GetQuotedColumnName));

        return string.Format(
            CreateConstraint,
            GetQuotedTableName(table.Name),
            GetQuotedName(constraintName),
            "PRIMARY KEY",
            columns);
    }

    /// <inheritdoc />
    public override string FormatColumnRename(string? tableName, string? oldName, string? newName) =>
        string.Format(
            RenameColumn,
            GetQuotedTableName(tableName),
            GetQuotedColumnName(oldName),
            GetQuotedColumnName(newName));

    /// <inheritdoc />
    public override string FormatTableRename(string? oldName, string? newName) =>
        string.Format(RenameTable, GetQuotedTableName(oldName), GetQuotedTableName(newName));

    /// <inheritdoc />
    public override string DeleteDefaultConstraint =>
        throw new NotSupportedException("Default constraints are not supported in PostgreSQL");

    /// <inheritdoc />
    public override string Length => "LENGTH";

    /// <inheritdoc />
    public override string Substring => "SUBSTRING";

    /// <inheritdoc />
    public override string CreateTable => "CREATE TABLE {0} ({1})";

    /// <inheritdoc />
    public override string DropTable => "DROP TABLE {0} CASCADE";

    /// <inheritdoc />
    public override string AddColumn => "ALTER TABLE {0} ADD COLUMN {1}";

    /// <inheritdoc />
    public override string DropColumn => "ALTER TABLE {0} DROP COLUMN {1} CASCADE";

    /// <inheritdoc />
    public override string AlterColumn => "ALTER TABLE {0} ALTER COLUMN {1} TYPE {2}";

    /// <inheritdoc />
    public override string RenameColumn => "ALTER TABLE {0} RENAME COLUMN {1} TO {2}";

    /// <inheritdoc />
    public override string RenameTable => "ALTER TABLE {0} RENAME TO {1}";

    /// <inheritdoc />
    public override string CreateSchema => "CREATE SCHEMA {0}";

    /// <inheritdoc />
    public override string AlterSchema => "ALTER SCHEMA {0} TRANSFER {1}.{2}";

    /// <inheritdoc />
    public override string DropSchema => "DROP SCHEMA {0} CASCADE";

    /// <inheritdoc />
    public override string CreateIndex => "CREATE {0} INDEX {2} ON {3} ({4})";

    /// <inheritdoc />
    public override string DropIndex => "DROP INDEX {0} CASCADE";

    /// <inheritdoc />
    public override string InsertData => "INSERT INTO {0} ({1}) VALUES ({2})";

    /// <inheritdoc />
    public override string UpdateData => "UPDATE {0} SET {1} WHERE {2}";

    /// <inheritdoc />
    public override string DeleteData => "DELETE FROM {0} WHERE {1}";

    /// <inheritdoc />
    public override string TruncateTable => "TRUNCATE TABLE {0} CASCADE";

    /// <inheritdoc />
    public override string CreateConstraint => "CONSTRAINT {1} {2} ({3})"; // "ALTER TABLE {0} ADD CONSTRAINT {1} {2} ({3})";

    /// <inheritdoc />
    public override string DeleteConstraint => "ALTER TABLE {0} DROP CONSTRAINT {1} CASCADE";

    /// <inheritdoc />
    public override string ConvertIntegerToOrderableString => "LPAD(CAST({0} AS TEXT), 8, '0')";

    /// <inheritdoc />
    public override string ConvertDateToOrderableString => "TO_CHAR({0}, 'YYYYMMDDHH24MISS')";

    /// <inheritdoc />
    public override string ConvertDecimalToOrderableString => "LPAD(REPLACE(CAST({0} AS TEXT), '.', ''), 20, '0')";

    /// <inheritdoc />
    public override string ConvertUniqueIdentifierToString => "CAST({0} AS NATIONAL CHARACTER VARYING(36))";

    /// <inheritdoc />
    public override string GetSpecialDbType(SpecialDbType dbType, int customSize) =>
        $"{GetSpecialDbType(dbType)}({customSize})";

    /// <inheritdoc />
    protected override string FormatCascade(string onWhat, Rule rule)
    {
        var action = "NO ACTION";
        switch (rule)
        {
            case Rule.None:
                return string.Empty;
            case Rule.Cascade:
                action = "CASCADE";
                break;
            case Rule.SetNull:
                action = "SET NULL";
                break;
            case Rule.SetDefault:
                action = "SET DEFAULT";
                break;
        }
        return $" ON {onWhat} {action}";
    }

    /// <inheritdoc />
    protected override string FormatString(ColumnDefinition column) => GetQuotedColumnName(column.Name);

    /// <inheritdoc />
    protected override string FormatType(ColumnDefinition column)
    {
        if (column.Type.HasValue == false && string.IsNullOrEmpty(column.CustomType) == false)
        {
            return column.CustomType;
        }

        if (column.CustomDbType.HasValue)
        {
            if (column.Size != default)
            {
                return GetSpecialDbType(column.CustomDbType.Value, column.Size);
            }
            return GetSpecialDbType(column.CustomDbType.Value);
        }

        Type type = column.Type.HasValue
            ? DbTypeMap.ColumnDbTypeMap.First(x => x.Value == column.Type.Value).Key
            : column.PropertyType;

        if (type == typeof(string))
        {
            var valueOrDefault = column.Size != default ? column.Size : DefaultStringLength;
            return string.Format(StringLengthColumnDefinitionFormat, valueOrDefault);
        }

        if (type == typeof(decimal))
        {
            var precision = column.Size != default ? column.Size : DefaultDecimalPrecision;
            var scale = column.Precision != default ? column.Precision : DefaultDecimalScale;
            return string.Format(DecimalColumnDefinitionFormat, precision, scale);
        }

        var definition = DbTypeMap.ColumnTypeMap[type];
        var dbTypeDefinition = column.Size != default
            ? $"{definition}({column.Size})"
            : definition;
        return dbTypeDefinition;
    }

    /// <inheritdoc />
    protected override string FormatNullable(ColumnDefinition column) => column.IsNullable ? "NULL" : "NOT NULL";

    /// <inheritdoc />
    protected override string FormatConstraint(ColumnDefinition column)
    {
        if (string.IsNullOrEmpty(column.ConstraintName) && column.DefaultValue == null)
        {
            return string.Empty;
        }
        return
            $"CONSTRAINT {(string.IsNullOrEmpty(column.ConstraintName) ? GetQuotedName($"DF_{column.TableName}_{column.Name}") : column.ConstraintName)}";
    }

    /// <inheritdoc />
    protected override string FormatDefaultValue(ColumnDefinition column)
    {
        if (column.DefaultValue == null)
        {
            return string.Empty;
        }

        if (string.Equals(column.DefaultValue.ToString(), "NOW()", StringComparison.OrdinalIgnoreCase))
        {
            column.DefaultValue = SystemMethods.CurrentDateTime;
        }

        if (column.DefaultValue is SystemMethods systemMethod)
        {
            var method = FormatSystemMethods(systemMethod);
            return string.IsNullOrEmpty(method) ? string.Empty : string.Format(DefaultValueFormat, method);
        }

        return string.Format(DefaultValueFormat, GetQuotedValue(column.DefaultValue.ToString()!));
    }

    /// <inheritdoc />
    protected override string FormatPrimaryKey(ColumnDefinition column) => string.Empty;

    /// <inheritdoc />
    protected override string? FormatSystemMethods(SystemMethods systemMethod)
    {
        // Map Umbraco's SystemMethods to PostgreSQL expressions.
        return systemMethod switch
        {
            SystemMethods.CurrentUTCDateTime => "timezone('utc'::text, now())",
            SystemMethods.CurrentDateTime => "timezone('utc'::text, now())",
            SystemMethods.NewGuid => "gen_random_uuid()", // Requires pgcrypto extension; otherwise use uuid_generate_v4()
            _ => null
        };
    }

    /// <inheritdoc />
    protected override string FormatIdentity(ColumnDefinition column)
    {
        // For PostgreSQL, use SERIAL for auto-increment integer columns.
        // If the column is an identity/auto-increment, return the SERIAL keyword.
        // Otherwise, return an empty string.
        if (column.IsIdentity)
        {
            // Use BIGSERIAL for long/bigint, SERIAL for int
            Type type = column.Type.HasValue
                ? DbTypeMap.ColumnDbTypeMap.First(x => x.Value == column.Type.Value).Key
                : column.PropertyType;

            if (type == typeof(long))
            {
                return AutoIncrementLongDefinition;
            }

            return AutoIncrementDefinition;
        }

        return string.Empty;
    }

    /// <inheritdoc />
    public override Sql<ISqlContext>.SqlJoinClause<ISqlContext> LeftJoinWithNestedJoin<TDto>(
        Sql<ISqlContext> sql,
        Func<Sql<ISqlContext>, Sql<ISqlContext>> nestedJoin,
        string? alias = null)
    {
        Type type = typeof(TDto);

        var tableName = GetQuotedTableName(type.GetTableName());
        var join = tableName;

        if (alias != null)
        {
            var quotedAlias = GetQuotedTableName(alias);
            join += " " + quotedAlias;
        }

        var nestedSql = new Sql<ISqlContext>(sql.SqlContext);
        nestedSql = nestedJoin(nestedSql);

        Sql<ISqlContext>.SqlJoinClause<ISqlContext> sqlJoin = sql.LeftJoin(join);
        sql.Append(nestedSql);
        return sqlJoin;
    }

    /// <inheritdoc />
    public override Sql<ISqlContext> SelectTop(Sql<ISqlContext> sql, int top)
    {
        // PostgreSQL uses LIMIT at the  end of the select sql as opposed to TOP
        // SELECT TOP 5 * FROM My_Table
        // SELECT * FROM My_Table LIMIT 5;
        return sql.Append($"LIMIT {top}");
    }

    #region implementation for abstract methods from SqlSyntaxProviderBase

    public override IEnumerable<Tuple<string, string, string, bool>> GetDefinedIndexes(IDatabase db)
    {
        // This query returns: TableName, IndexName, ColumnName, IsUnique (excluding primary keys)
        const string sql = @"
            SELECT
                t.relname AS tablename,
                i.relname AS indexname,
                a.attname AS columnname,
                ix.indisunique AS isunique
            FROM
                pg_class t
                INNER JOIN pg_index ix ON t.oid = ix.indrelid
                INNER JOIN pg_class i ON i.oid = ix.indexrelid
                INNER JOIN pg_namespace n ON n.oid = t.relnamespace
                LEFT JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)
            WHERE
                n.nspname = 'public'
                AND NOT ix.indisprimary
                AND i.relkind = 'i'
            ORDER BY
                t.relname, i.relname, a.attnum;
        ";

        // Map the result to the expected tuple
        var result = db.Fetch<dynamic>(sql);
        foreach (var row in result)
        {
            yield return new Tuple<string, string, string, bool>(
                (string)row.tablename,
                (string)row.indexname,
                (string)row.columnname,
                (bool)row.isunique
            );
        }
    }

    public override bool TryGetDefaultConstraint(IDatabase db, string? tableName, string columnName, [MaybeNullWhen(false)] out string constraintName)
    {
        if (string.IsNullOrEmpty(tableName))
        {
            constraintName = null;
            return false;
        }

        // Query the default value for the column from information_schema
        const string sql = @"
            SELECT column_default
            FROM information_schema.columns
            WHERE table_schema = 'public'
              AND table_name = @0
              AND column_name = @1
            LIMIT 1;
        ";

        constraintName = null;
        var defaultValue = db.ExecuteScalar<string>(sql, tableName, columnName);

        if (!string.IsNullOrEmpty(defaultValue))
        {
            // PostgreSQL does not have a constraint name, but we can return the default expression
            constraintName = defaultValue;
            return true;
        }

        return false;
    }

    private class ConstraintsPerColumn
    {
        public string TableName { get; set; } = string.Empty;
        public string ColumnName { get; set; } = string.Empty;
        public string ConstraintName { get; set; } = string.Empty;
    }

    #endregion implementation for abstract methods from SqlSyntaxProviderBase
}
